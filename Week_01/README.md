# 学习笔记

## Day1

###五毒神掌！！！！！

    1.5-10分钟读题，尝试找到解题思路。时间到，没有思路，直接看题解，找到最优方法，理解代码
    
    2.尝试自己实现代码，提交leetcode，尝试多种方法实现
    
    3.24小时之后，再次实现一边
    
    4.一周之后再次实现一遍
    
    5.面试前一周，再次过一遍
 
###切题思路


    1.理解题目要求
    
    2.找出多种解决思路，对比时间空间复杂度，找到最优方法
    
    3.自己手动实现
    
    4.测试用例

###跳表
    # 操作有序列表，对标平衡二叉树，查找删除搜索都是O(logn)
    # 优化一维数据， 升纬度
    

###爬楼梯

    解题思路：
        每次只能跨一阶 或者 两阶
        想要爬到第n层 有两种方法：
            1。前一层，跨一阶
            2。前两层，跨两阶
        所以，如果到前一层的方法数 和 到前两层的方法数 相加之和，就是爬到第n层的方法数
        ...
        依此类推
        ...
        直到推到 我们已知的 第二层 和 第一层， 就可以反向递归出爬到第n层的方法数
        
        或者我们正向思考，
        第三层 = 第二层 + 第一层
        第四层 = 第三层 + 第二层 
        ...
        第n层 = 第n-1层 + 第n-2层
        遍历得出爬到n层的方法数
---
        时间复杂度：反向递归（带缓存，否则是O(2^n)）和正向遍历都是O(n)
        
        空间复杂度：
        
            --正向很好理解，只需用两个变量，
              一个存前两层的值，一个存前一层的值，互相转换， 空间复杂度O(1)
              
            --反向容易在缓存中，未及时清除过期的数据，导致O(n),
              及时清理过期缓存数据，空间复杂度可降至O(1)


###三数之和
    
    返回列表中所有 三元素 which 和 等于零
    
    解题思路：
    对列表进行排序
    先确定最小的元素，再在最小元素的右边，用双指针夹逼确定 其他两个元素
    如果指针相遇，
    则遍历确定下一个最小的元素，再在当前最小元素的右边，用双指针夹逼确定 其他两个元素
    
    以此类推
    
    如果最小的元素都大于0，则可以提前结束程序，返回已知结果
    
    滑动确定最小的元素 和使用 双指针滑动 解决了 三元素重复的问题
    
    
###数组总和

    题干：
    求一个无重复正整数组成数组内，元素之和是target的所有元素组合，组合内元素可以重复，
    组合组合之间不允许重复
    
    正向思考：
    因为要不重复，所以计算时最好把题目给的数组排序，方便把结果按照一定顺序遍历出来
    
    
    把数组嵌套n遍，从第一个元素 向 下一层第一个元素做累加，累加结果小于target，
    就再下一层
    直到累加结果等于或者大于target
    这期间，每次下一层，都分配一个资源空间，用于记录路径
    
    等于的话，记录一下路径， 同时告诉上一层，我这一层的剩余元素无需再去尝试，因为排序了   后面都比我大
    
    大于的话，路径就不管他了， 告诉上一层就更不用了在考虑我这层剩余的元素了
    
    上一层如果能收到他下一层嵌套发回的 停止他继续遍历的的信息，则停止遍历，
    把它分配出去记录路径的资源收回
    之后告诉他的 上一层，我这里能做的都做了，你去遍历我的兄弟试试吧
    
    直到返回第一层嵌套，表示第一个元素所有的可能都找一了一遍，那就开始下一个元素，
    下一个元素也是向下做累加，但是对她来说，嵌套的数组已经排除了第一个元素，
    这样第一个元素就不会出现在她的可能里，就不会出现重复的组合


###最小栈
    解题思路有三，空间复杂度逐级减少
    1。栈内元素升纬度，可携带信息，容易整理逻辑，但是空间复杂度比较大
    2。使用一个参数记录最小值，并把上一个最小值的差距放在栈内前一位
    3。制定规则，声明当前最小值，
        所有元素与最小值 做差 后处理后入栈，
        如果做差后， 差小于零， 再重新设定最小值为最小的处理前元素
        每次大于零的元素出栈，都会加上最小值
        每次负值出栈，都会返回最小值，并更新最小值
    
    
    
    
    