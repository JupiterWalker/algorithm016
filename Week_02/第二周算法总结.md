学习笔记

###deque(双端队列)
双端队列是一种 队列结构 --> 可以规定队列长度
双端队列的双端 可以在两端进行 入列 和 出列 的操作
实现方式 由 每段长度为64的block组成的双链表，两边头尾可能是不完整的

相对比list
                     list           deque
append,pop           O(1)           O(1)
left append,pop      O(n)           O(1)    # list在头部删除，其他位都需要前进一位，在头部增加，所有位都需要后退一位
                                            # deque只需要在第一个block中的元素移动，元素为常数位
index 取操作         O(1)            O(N/64) # 需要先找到目标元素所在的block，block之间是双链表
index删除操作        O(n)            O(n/2)  # list删除元素后，只会把所有的后面的元素移动前一位
                                            # deque会很据删除元素的位置，来进行判断 移动哪边的元素最少移动那一边

deque 随机访问的解释
'''与双链表相比，双端队列的实现要聪明一些。 它们是Python对象块的双向链接列表，其中左侧和右侧可能是不完整的块。
中间访问的Big-O成本仍然是O（n），但它具有恒定的除数（取决于实现，CPython 3.5分配可存储64个对象的块）。 因此，如果您的双端队列有1000个成员，则在中间访问仍仅涉及7-8个“链表式”遍历，而不是500遍。 如果双端队列较小（65到128个元素，具体取决于空插槽与头部和尾部对齐的方式），则查找任何元素的成本都相等。'''

总结：
deque最合适的场景：
    -针对头尾操作的对象
    -随机删除操作
list最适合的场景：
    -随机index的取

队列进行index取操作的对象分情况：
    -index小于64 deque的效率和list差不多
    -index大的时候，list是O(1), deque是0(n/64)

###heap堆
python中的堆是一个小顶堆， 由完全二叉树实现的
完全二叉树可以以用数组结构存储

##判断父子节点的公式：
如果根节点的下标是i，那么它的左节点的下标是2*i+1,他的右节点的下标是2*i+2
相反，如果子节点的下标是k，那么它的根节点下标是floor((k -i)/2), floor代表向下取整

##由以上确定父子节点位置的方法，再加上下面介绍的增加删除操作的规则，我们就可以轻松维护一个二叉堆

##增加删除操作的规则
增加：
1.先在尾部添加
2.跟父节点对比，比父节点小，就交换，以此类推，直到自己是根节点或者不比父节点大为止

删除：
1.把末尾的元素 填充到删除位置上
2.找出子节点最小的， 在跟自己最对比，如果最小孩子比自己小，进行交换，以此类推，直到孩子都比自己大

push,pop      O(logn)
heapify       O(nlogn)    #相当于把n个元素依次入堆

##概念分类
(Binary Search Tree):
    -可以称为：二叉搜索树,二叉查找树,有序二叉树,排序二叉树
    -记忆窍门：中序遍历是一个递增的有序数组

(Complete Binary Tree)
    -完全二叉树：节点都是从上至下，从左至右的安排进树内的
    -由于是连续的，可以用数组标识，在数组中该树的有规则如下：
        如果根节点的下标是i，那么它的左节点的下标是2*i+1,他的右节点的下标是2*i+2
        相反，如果子节点的下标是k，那么它的根节点下标是floor((k -i)/2), floor代表向下取整
    -记忆窍门：把米放进盒子里

AVL树：
    -平衡二叉树:由于BST的极端情况下的链表状态，对于搜索是不友好的，时间复杂度为O(n), 由此而产生的一种树
    -概念：左右子树高度差不能大于1
    -记忆窍门：一个有序的类似完全二叉树的树



