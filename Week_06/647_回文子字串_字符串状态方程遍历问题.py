# coding:utf-8
__author__ = 'cwang14'
# 题目：
# 给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。
#
# 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
#
#
# 示例 1：
#
# 输入："abc"
# 输出：3
# 解释：三个回文子串: "a", "b", "c"
# 示例 2：
#
# 输入："aaa"
# 输出：6
# 解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
#

# 字符串问题应该诉诸于二维展开解决， 所以递归结构是一个二维数组，
# 又因为是头尾问题， 头在前， 尾在后， 顺序不能颠倒， 所以可以想象到，递归结构只会占用二维数组的右上角部分
# 又因为是头尾问题， 状态变量可以剥离出 start=》头 和 end=》尾
# 接下来看， 头尾的取值和  这个范围内字符串 和 回文字符串 的关系
# 当 start == end时 ， 字符串只有一个字节， 由题意得， 该状态为回文字符串
#     if start == end: DP[start][end] = True

# 当start+1==end时 也就是开头和结尾字符相邻的情况下 s[start]==s[end]时， 该状态为回文字符串
#     if start+1 == end s[start]==s[end] and : DP[start][end] = True

# 当头尾之间不重合也不相邻的其他情况， 要想囊括的字符串是回文字符， 则必须s[start]==s[end]，
# 且除他们之外的字符串也必须是回文的
#     if s[start]==s[end] and DP[start+1][end-1]==True: DP[start][end] = True

# 这样我们就得出了本题的状态转移方程
# 但是，正常的状态转移方程都是DP[n] = f(DP[m])  m<n 这样的
# 可是 要得到DP[start][end] 需要得到DP[start+1][end-1]
# 我们都知道，状态转移方程是根据之前的状态的返回结果 来计算 现在的结果，
# 平时我们都是正向遍历所以， 大家有个思维惯性， 认为 DP[n] = f(DP[m])  m<n
# 但既然时我们现在 状态变量start需要之后的结果 来计算现在， 那么我们就直接对相应的状态变量反向遍历 不就好了嘛
# for start in range(len(s)-1, -1, -1):
#    for end in range(len(s)):
#       pass
